<canvas id="springMassCanvas" class="spring-mass-canvas"></canvas>

<script type="module">
    import { Slider } from '/js/range_slider.js';

    function getRandInteger(min, max) {
        return Math.floor(Math.random() * (max - min + 1)) + min;
    }

    class DrawableOject {
        constructor(initialX, initialY, imageSrc) {
            this.x = initialX;
            this.y = initialY;
            this.image = new Image();
            this.image.src = imageSrc;
        }

        draw(ctx) {
            ctx.drawImage(this.image, this.x, this.y, this.image.width, this.image.height);
        }

        inBoundingBox(x, y) {
            return (x > this.x && x < this.x + this.image.width && y > this.y && y < this.y + this.image.height);
        }
    }

    class Spring extends DrawableOject {
        constructor(
            initialX,
            initialY,
            imageSrc,
            naturalLength,
            minLength,
            maxLength,
            stiffness,
            minSpringStiffness,
            maxSpringStiffness
        ) {
            super(initialX, initialY, imageSrc);
            this.length = naturalLength;
            this.naturalLength = naturalLength;
            this.maxLength = maxLength;
            this.minLength = minLength;
            this.stiffness = stiffness;
            this.minSpringStiffness = minSpringStiffness;
            this.maxSpringStiffness = maxSpringStiffness;

            this.image.onload = () => {
                this.springWidth = this.calcSpringWidth();
            };

            new Slider("stiffness_slider", this.updateStiffness.bind(this), this.stiffness, this.minSpringStiffness, this.maxSpringStiffness);
        }

        updateStiffness(newStiffness) {
            this.stiffness = newStiffness;
            this.springWidth = this.calcSpringWidth();
        }

        calcSpringWidth() {
            return this.image.width * (0.4 + 0.6 * (this.stiffness - this.minSpringStiffness) /
            (this.maxSpringStiffness - this.minSpringStiffness));
        }

        calcSpringLength(bottomSpringPosition, lengthToPixels) {
            return (bottomSpringPosition - this.y) / lengthToPixels;
        }

        draw(ctx) {
            ctx.drawImage(this.image, this.x - this.springWidth/2, this.y, this.springWidth, spring.length*lengthToPixels);
        }
    }

    class WeightBlock extends DrawableOject {
        constructor(initialX, initialY, imageSrc, mass, velocity = 0, acceleration = 0) {
            super(initialX, initialY, imageSrc);
            this.mass = mass;
            this.velocity = velocity;
            this.acceleration = acceleration;
        }
    }

    class Damping {
        constructor(dampingCoefficient, minDampingCoefficient, maxDampingCoefficient) {
            new Slider("damping_slider", this.updateDamping.bind(this), dampingCoefficient, minDampingCoefficient, maxDampingCoefficient);
            this.damping = dampingCoefficient;
        }

        updateDamping(newDampingCoefficient) {
            this.damping = newDampingCoefficient;
        }
    }

    class Brush {
        constructor(brushDiameter, bristleRaiseProbability, bristleDownProbability) {
            this.maxPathLength = 150;
            this.pathValues = [];
            this.baseVerticalOffset = 0.8 * baseHeight;
            this.startX = 0;
            this.endX = baseWidth * 2/3 - massWidth / 2 + brushDiameter/2;

            this.brushFade = ctx.createLinearGradient(40, 0, 200, 0);
            this.brushFade.addColorStop(0, "rgb(50, 50, 50, 0)");
            this.brushFade.addColorStop(1, "rgb(50, 50, 50, 0.3)");

            this.bristles = new Array(50).fill().map(
                () => new Bristle(this.maxPathLength, brushDiameter * 0.75, brushDiameter)
            );
        }

        addTrace(val) {
            this.pathValues.push(val);
            if (this.pathValues.length > this.maxPathLength) {
                this.pathValues.shift();
            }
        }

        draw(ctx) {
            this.bristles.forEach(bristle => this.drawPath(ctx, bristle));
        }

        drawPath(ctx, bristle) {
            let width = this.endX - this.startX;
            let firstX = this.startX + (this.maxPathLength - this.pathValues.length)/this.maxPathLength*width;

            ctx.lineWidth = bristle.bristleWidth;
            ctx.strokeStyle = this.brushFade;
            ctx.moveTo(this.firstX + bristle.xOffset, this.pathValues[0] + this.baseVerticalOffset + bristle.yOffset);
            ctx.beginPath();
            for (let i = 0; i < this.pathValues.length; i++) {
                let x = firstX + bristle.xOffset + (i/this.maxPathLength) * width;
                let y = this.baseVerticalOffset + bristle.yOffset + this.pathValues[i];
                ctx.lineTo(x, y);
            }
            ctx.stroke();
        }
    }
    
    class Bristle {
        constructor(traceLength, brushWidth, brushHeight) {
            this.xOffset = getRandInteger(-brushWidth/2, brushWidth/2);
            this.yOffset = getRandInteger(-brushHeight/2, brushHeight/2);
            this.bristleWidth = Math.random() > 0.5 ? 1 : 2;
        }
    }

    let base;
    let weightBlock;
    let spring;
    let damping;
    let brush;

    let ctx;

    let previousLoopTimeMs;
    let mouseSelectOffsetY;
    let currentDragY = 0;
    let previousDragY = 0;
    let previousScrollPosition = 0;
    let previousScrollSpeed = 0;
    let scrollAcceleration = 0;
    let lastScrollTime = Date.now();

    let pauseSimulation = false;
    let isBlockSelected = false;

    const baseWidth = 700;
    const baseHeight = 130;
    const springWidth = 196;
    const massWidth = 196;
    const massHeight = 156;
    const lengthToPixels = 300; 

    let canvas = document.getElementById("springMassCanvas");
    canvas.width = baseWidth;
    canvas.height = baseWidth * 1.2;

    const minSpringStiffness = 40;
    const maxSpringStiffness = 200;
    const initialSpringStiffness = 120;
    const springNaturalLength = 0.8;
    const springMinLength = 0.1;
    const springMaxLength = 0.64 * canvas.height / lengthToPixels;
    const blockMass = 1;
    const initialDampingCoefficient = 3;
    const minDampingCoefficient = 0.1;
    const maxDampingCoefficient = 10;

    const gravity = 9.81;
    let t = 0;


    function convertPageToCanvasPos(pageX, pageY) {
        const rect = canvas.getBoundingClientRect();
        const pageToCanvasXPixelScale = canvas.width / rect.width;
        const pageToCanvasYPixelScale = canvas.height / rect.height;
        return {
            canvasX: (pageX - rect.left) * pageToCanvasXPixelScale,
            canvasY: (pageY - rect.top) * pageToCanvasYPixelScale
        };
    }


    function init() {
        base = new DrawableOject(0, 0, "/images/springmass/springbase.png");
        spring = new Spring(baseWidth*2/3, baseHeight-16, "/images/springmass/spring.png", springNaturalLength, springMinLength, springMaxLength, initialSpringStiffness, minSpringStiffness, maxSpringStiffness);
        weightBlock = new WeightBlock(baseWidth*2/3 - massWidth/2, 0, "/images/springmass/mass.png", blockMass);
        damping = new Damping(initialDampingCoefficient, minDampingCoefficient, maxDampingCoefficient);
        brush = new Brush(20, 0, 0);

        ctx = canvas.getContext("2d");

        window.addEventListener('scroll', (e) => {
            let currentScrollPosition = window.scrollY / lengthToPixels;


            let scrollDeltaTimeS = (Date.now() - lastScrollTime)/1000;
            if (scrollDeltaTimeS > 4/60) {
                scrollDeltaTimeS = 1/60;
                previousScrollSpeed = 0;
            }
            let scrollSpeed = (currentScrollPosition - previousScrollPosition) / scrollDeltaTimeS;
            scrollAcceleration = (scrollSpeed - previousScrollSpeed) / scrollDeltaTimeS;
            scrollAcceleration = Math.min(scrollAcceleration, 20);

            previousScrollPosition = currentScrollPosition;
            previousScrollSpeed = scrollSpeed;
            lastScrollTime = Date.now();
        });

        const handleSelectMass = (e) => {
            const { clientX, clientY } = e.touches ? e.touches[0] : e;
            const { canvasX, canvasY } = convertPageToCanvasPos(clientX, clientY);

            if (weightBlock.inBoundingBox(canvasX, canvasY)) {
                pauseSimulation = true;
                isBlockSelected = true;
                mouseSelectOffsetY = canvasY - weightBlock.y;

                currentDragY, previousDragY = canvasY;
            }
        };

        canvas.addEventListener("mousedown", handleSelectMass);
        canvas.addEventListener("touchstart", handleSelectMass);

        function calcBottomSpringPosition(targetCanvasY, spring) {
            const springTopLimit = spring.y + spring.maxLength*lengthToPixels;
            const springBottomLimit = spring.y + spring.minLength*lengthToPixels;

            if (targetCanvasY > springTopLimit) {
                return springTopLimit;
            } else if (targetCanvasY < springBottomLimit) {
                return springBottomLimit;
            }
            return targetCanvasY;
        }

        const handleMoveMass = (e) => {
            const { clientX, clientY } = e.touches ? e.touches[0] : e;
            const { canvasX, canvasY } = convertPageToCanvasPos(clientX, clientY);

            if (!e.touches) { // Has a mouse cursor
                canvas.style.cursor = weightBlock.inBoundingBox(canvasX, canvasY) ? 'pointer' : 'default';
            }
            
            if (isBlockSelected) {
                if (e.touches) e.preventDefault(); // prevent scrolling on mobile

                const targetYPosition = canvasY - mouseSelectOffsetY;
                const newBottomSpringPosition = calcBottomSpringPosition(targetYPosition, spring);
                spring.length = spring.calcSpringLength(newBottomSpringPosition, lengthToPixels);

                previousDragY = currentDragY;     
            } else {
                previousDragY = canvasY;
            }
            currentDragY = canvasY;
        };

        canvas.addEventListener("mousemove", handleMoveMass);
        canvas.addEventListener("touchmove", handleMoveMass, { passive: false });

        const handleUnselectMass = (e) => {
            if (isBlockSelected) {        
                isBlockSelected = false;
                pauseSimulation = false;
                weightBlock.velocity = (currentDragY - previousDragY) / lengthToPixels / (1/60);
                weightBlock.acceleration = 0;
            }
        };

        document.addEventListener("mouseup", handleUnselectMass);
        document.addEventListener("touchend", handleUnselectMass);

        window.requestAnimationFrame(draw);
    }

    function calculateNewState(blockMass, spring, timeElapsedS, scrollAcceleration, pauseSpringForces) {
        if (!pauseSimulation) {
            blockMass.acceleration = gravity + scrollAcceleration - (spring.stiffness/blockMass.mass) * (spring.length - spring.naturalLength) - Math.sign(blockMass.velocity) * damping.damping;
            
            if (spring.length > spring.maxLength || spring.length < spring.minLength) {
                blockMass.velocity = 0;
                spring.length = spring.length > spring.maxLength ? spring.maxLength : spring.minLength;
            } else {
                blockMass.velocity += blockMass.acceleration * timeElapsedS;
                spring.length += 0.5 * blockMass.velocity * timeElapsedS;
            }
        }
        blockMass.y = spring.length*lengthToPixels + baseHeight - 30;
    }

    function draw(currentTimeMs) {
        previousLoopTimeMs = previousLoopTimeMs || currentTimeMs - 1000/60;
        let timeElapsedS = Math.min((currentTimeMs - previousLoopTimeMs)/1000, 1/10);
        previousLoopTimeMs = currentTimeMs;

        calculateNewState(weightBlock, spring, timeElapsedS, scrollAcceleration, pauseSimulation);
        brush.addTrace(weightBlock.y);
        scrollAcceleration = 0;

        // Log state
        t += 1;
        if (t == 10000) {
            t = 0;
            console.log(weightBlock.acceleration, weightBlock.velocity, spring.length);
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        brush.draw(ctx);
        base.draw(ctx);
        weightBlock.draw(ctx);
        spring.draw(ctx);

        window.requestAnimationFrame(draw);
    }

    init();
</script>
